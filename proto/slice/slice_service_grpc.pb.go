// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v5.27.3
// source: slice_service.proto

package slicev1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	SliceService_CheckoutSlice_FullMethodName         = "/slice.v1.SliceService/CheckoutSlice"
	SliceService_CreateChangeset_FullMethodName       = "/slice.v1.SliceService/CreateChangeset"
	SliceService_ReviewChangeset_FullMethodName       = "/slice.v1.SliceService/ReviewChangeset"
	SliceService_MergeChangeset_FullMethodName        = "/slice.v1.SliceService/MergeChangeset"
	SliceService_RebaseChangeset_FullMethodName       = "/slice.v1.SliceService/RebaseChangeset"
	SliceService_GetSliceCommits_FullMethodName       = "/slice.v1.SliceService/GetSliceCommits"
	SliceService_GetSliceState_FullMethodName         = "/slice.v1.SliceService/GetSliceState"
	SliceService_ListChangesets_FullMethodName        = "/slice.v1.SliceService/ListChangesets"
	SliceService_StreamCheckoutSlice_FullMethodName   = "/slice.v1.SliceService/StreamCheckoutSlice"
	SliceService_StreamCreateChangeset_FullMethodName = "/slice.v1.SliceService/StreamCreateChangeset"
)

// SliceServiceClient is the client API for SliceService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SliceServiceClient interface {
	// Checkout slice for editing
	CheckoutSlice(ctx context.Context, in *CheckoutRequest, opts ...grpc.CallOption) (*CheckoutResponse, error)
	// Create a new change list
	CreateChangeset(ctx context.Context, in *CreateChangesetRequest, opts ...grpc.CallOption) (*CreateChangesetResponse, error)
	// Review a change list (check against slice head)
	ReviewChangeset(ctx context.Context, in *ReviewChangesetRequest, opts ...grpc.CallOption) (*ReviewChangesetResponse, error)
	// Merge change list into slice (with conflict detection)
	MergeChangeset(ctx context.Context, in *MergeChangesetRequest, opts ...grpc.CallOption) (*MergeChangesetResponse, error)
	// Rebase change list on new slice head
	RebaseChangeset(ctx context.Context, in *RebaseChangesetRequest, opts ...grpc.CallOption) (*RebaseChangesetResponse, error)
	// Get slice commit history
	GetSliceCommits(ctx context.Context, in *CommitHistoryRequest, opts ...grpc.CallOption) (*CommitHistoryResponse, error)
	// Get current slice state
	GetSliceState(ctx context.Context, in *StateRequest, opts ...grpc.CallOption) (*StateResponse, error)
	// List pending change lists for a slice
	ListChangesets(ctx context.Context, in *ListChangesetsRequest, opts ...grpc.CallOption) (*ListChangesetsResponse, error)
	// Stream checkout for large slices (server streaming)
	StreamCheckoutSlice(ctx context.Context, in *CheckoutRequest, opts ...grpc.CallOption) (SliceService_StreamCheckoutSliceClient, error)
	// Stream changeset creation (client streaming)
	StreamCreateChangeset(ctx context.Context, opts ...grpc.CallOption) (SliceService_StreamCreateChangesetClient, error)
}

type sliceServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSliceServiceClient(cc grpc.ClientConnInterface) SliceServiceClient {
	return &sliceServiceClient{cc}
}

func (c *sliceServiceClient) CheckoutSlice(ctx context.Context, in *CheckoutRequest, opts ...grpc.CallOption) (*CheckoutResponse, error) {
	out := new(CheckoutResponse)
	err := c.cc.Invoke(ctx, SliceService_CheckoutSlice_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sliceServiceClient) CreateChangeset(ctx context.Context, in *CreateChangesetRequest, opts ...grpc.CallOption) (*CreateChangesetResponse, error) {
	out := new(CreateChangesetResponse)
	err := c.cc.Invoke(ctx, SliceService_CreateChangeset_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sliceServiceClient) ReviewChangeset(ctx context.Context, in *ReviewChangesetRequest, opts ...grpc.CallOption) (*ReviewChangesetResponse, error) {
	out := new(ReviewChangesetResponse)
	err := c.cc.Invoke(ctx, SliceService_ReviewChangeset_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sliceServiceClient) MergeChangeset(ctx context.Context, in *MergeChangesetRequest, opts ...grpc.CallOption) (*MergeChangesetResponse, error) {
	out := new(MergeChangesetResponse)
	err := c.cc.Invoke(ctx, SliceService_MergeChangeset_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sliceServiceClient) RebaseChangeset(ctx context.Context, in *RebaseChangesetRequest, opts ...grpc.CallOption) (*RebaseChangesetResponse, error) {
	out := new(RebaseChangesetResponse)
	err := c.cc.Invoke(ctx, SliceService_RebaseChangeset_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sliceServiceClient) GetSliceCommits(ctx context.Context, in *CommitHistoryRequest, opts ...grpc.CallOption) (*CommitHistoryResponse, error) {
	out := new(CommitHistoryResponse)
	err := c.cc.Invoke(ctx, SliceService_GetSliceCommits_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sliceServiceClient) GetSliceState(ctx context.Context, in *StateRequest, opts ...grpc.CallOption) (*StateResponse, error) {
	out := new(StateResponse)
	err := c.cc.Invoke(ctx, SliceService_GetSliceState_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sliceServiceClient) ListChangesets(ctx context.Context, in *ListChangesetsRequest, opts ...grpc.CallOption) (*ListChangesetsResponse, error) {
	out := new(ListChangesetsResponse)
	err := c.cc.Invoke(ctx, SliceService_ListChangesets_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sliceServiceClient) StreamCheckoutSlice(ctx context.Context, in *CheckoutRequest, opts ...grpc.CallOption) (SliceService_StreamCheckoutSliceClient, error) {
	stream, err := c.cc.NewStream(ctx, &SliceService_ServiceDesc.Streams[0], SliceService_StreamCheckoutSlice_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &sliceServiceStreamCheckoutSliceClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type SliceService_StreamCheckoutSliceClient interface {
	Recv() (*CheckoutChunk, error)
	grpc.ClientStream
}

type sliceServiceStreamCheckoutSliceClient struct {
	grpc.ClientStream
}

func (x *sliceServiceStreamCheckoutSliceClient) Recv() (*CheckoutChunk, error) {
	m := new(CheckoutChunk)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *sliceServiceClient) StreamCreateChangeset(ctx context.Context, opts ...grpc.CallOption) (SliceService_StreamCreateChangesetClient, error) {
	stream, err := c.cc.NewStream(ctx, &SliceService_ServiceDesc.Streams[1], SliceService_StreamCreateChangeset_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &sliceServiceStreamCreateChangesetClient{stream}
	return x, nil
}

type SliceService_StreamCreateChangesetClient interface {
	Send(*ChangesetChunk) error
	CloseAndRecv() (*CreateChangesetResponse, error)
	grpc.ClientStream
}

type sliceServiceStreamCreateChangesetClient struct {
	grpc.ClientStream
}

func (x *sliceServiceStreamCreateChangesetClient) Send(m *ChangesetChunk) error {
	return x.ClientStream.SendMsg(m)
}

func (x *sliceServiceStreamCreateChangesetClient) CloseAndRecv() (*CreateChangesetResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(CreateChangesetResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// SliceServiceServer is the server API for SliceService service.
// All implementations must embed UnimplementedSliceServiceServer
// for forward compatibility
type SliceServiceServer interface {
	// Checkout slice for editing
	CheckoutSlice(context.Context, *CheckoutRequest) (*CheckoutResponse, error)
	// Create a new change list
	CreateChangeset(context.Context, *CreateChangesetRequest) (*CreateChangesetResponse, error)
	// Review a change list (check against slice head)
	ReviewChangeset(context.Context, *ReviewChangesetRequest) (*ReviewChangesetResponse, error)
	// Merge change list into slice (with conflict detection)
	MergeChangeset(context.Context, *MergeChangesetRequest) (*MergeChangesetResponse, error)
	// Rebase change list on new slice head
	RebaseChangeset(context.Context, *RebaseChangesetRequest) (*RebaseChangesetResponse, error)
	// Get slice commit history
	GetSliceCommits(context.Context, *CommitHistoryRequest) (*CommitHistoryResponse, error)
	// Get current slice state
	GetSliceState(context.Context, *StateRequest) (*StateResponse, error)
	// List pending change lists for a slice
	ListChangesets(context.Context, *ListChangesetsRequest) (*ListChangesetsResponse, error)
	// Stream checkout for large slices (server streaming)
	StreamCheckoutSlice(*CheckoutRequest, SliceService_StreamCheckoutSliceServer) error
	// Stream changeset creation (client streaming)
	StreamCreateChangeset(SliceService_StreamCreateChangesetServer) error
	mustEmbedUnimplementedSliceServiceServer()
}

// UnimplementedSliceServiceServer must be embedded to have forward compatible implementations.
type UnimplementedSliceServiceServer struct {
}

func (UnimplementedSliceServiceServer) CheckoutSlice(context.Context, *CheckoutRequest) (*CheckoutResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckoutSlice not implemented")
}
func (UnimplementedSliceServiceServer) CreateChangeset(context.Context, *CreateChangesetRequest) (*CreateChangesetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateChangeset not implemented")
}
func (UnimplementedSliceServiceServer) ReviewChangeset(context.Context, *ReviewChangesetRequest) (*ReviewChangesetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReviewChangeset not implemented")
}
func (UnimplementedSliceServiceServer) MergeChangeset(context.Context, *MergeChangesetRequest) (*MergeChangesetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MergeChangeset not implemented")
}
func (UnimplementedSliceServiceServer) RebaseChangeset(context.Context, *RebaseChangesetRequest) (*RebaseChangesetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RebaseChangeset not implemented")
}
func (UnimplementedSliceServiceServer) GetSliceCommits(context.Context, *CommitHistoryRequest) (*CommitHistoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSliceCommits not implemented")
}
func (UnimplementedSliceServiceServer) GetSliceState(context.Context, *StateRequest) (*StateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSliceState not implemented")
}
func (UnimplementedSliceServiceServer) ListChangesets(context.Context, *ListChangesetsRequest) (*ListChangesetsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListChangesets not implemented")
}
func (UnimplementedSliceServiceServer) StreamCheckoutSlice(*CheckoutRequest, SliceService_StreamCheckoutSliceServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamCheckoutSlice not implemented")
}
func (UnimplementedSliceServiceServer) StreamCreateChangeset(SliceService_StreamCreateChangesetServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamCreateChangeset not implemented")
}
func (UnimplementedSliceServiceServer) mustEmbedUnimplementedSliceServiceServer() {}

// UnsafeSliceServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SliceServiceServer will
// result in compilation errors.
type UnsafeSliceServiceServer interface {
	mustEmbedUnimplementedSliceServiceServer()
}

func RegisterSliceServiceServer(s grpc.ServiceRegistrar, srv SliceServiceServer) {
	s.RegisterService(&SliceService_ServiceDesc, srv)
}

func _SliceService_CheckoutSlice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckoutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SliceServiceServer).CheckoutSlice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SliceService_CheckoutSlice_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SliceServiceServer).CheckoutSlice(ctx, req.(*CheckoutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SliceService_CreateChangeset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateChangesetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SliceServiceServer).CreateChangeset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SliceService_CreateChangeset_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SliceServiceServer).CreateChangeset(ctx, req.(*CreateChangesetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SliceService_ReviewChangeset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReviewChangesetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SliceServiceServer).ReviewChangeset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SliceService_ReviewChangeset_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SliceServiceServer).ReviewChangeset(ctx, req.(*ReviewChangesetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SliceService_MergeChangeset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MergeChangesetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SliceServiceServer).MergeChangeset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SliceService_MergeChangeset_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SliceServiceServer).MergeChangeset(ctx, req.(*MergeChangesetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SliceService_RebaseChangeset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RebaseChangesetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SliceServiceServer).RebaseChangeset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SliceService_RebaseChangeset_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SliceServiceServer).RebaseChangeset(ctx, req.(*RebaseChangesetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SliceService_GetSliceCommits_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CommitHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SliceServiceServer).GetSliceCommits(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SliceService_GetSliceCommits_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SliceServiceServer).GetSliceCommits(ctx, req.(*CommitHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SliceService_GetSliceState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SliceServiceServer).GetSliceState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SliceService_GetSliceState_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SliceServiceServer).GetSliceState(ctx, req.(*StateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SliceService_ListChangesets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListChangesetsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SliceServiceServer).ListChangesets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SliceService_ListChangesets_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SliceServiceServer).ListChangesets(ctx, req.(*ListChangesetsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SliceService_StreamCheckoutSlice_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(CheckoutRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SliceServiceServer).StreamCheckoutSlice(m, &sliceServiceStreamCheckoutSliceServer{stream})
}

type SliceService_StreamCheckoutSliceServer interface {
	Send(*CheckoutChunk) error
	grpc.ServerStream
}

type sliceServiceStreamCheckoutSliceServer struct {
	grpc.ServerStream
}

func (x *sliceServiceStreamCheckoutSliceServer) Send(m *CheckoutChunk) error {
	return x.ServerStream.SendMsg(m)
}

func _SliceService_StreamCreateChangeset_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(SliceServiceServer).StreamCreateChangeset(&sliceServiceStreamCreateChangesetServer{stream})
}

type SliceService_StreamCreateChangesetServer interface {
	SendAndClose(*CreateChangesetResponse) error
	Recv() (*ChangesetChunk, error)
	grpc.ServerStream
}

type sliceServiceStreamCreateChangesetServer struct {
	grpc.ServerStream
}

func (x *sliceServiceStreamCreateChangesetServer) SendAndClose(m *CreateChangesetResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *sliceServiceStreamCreateChangesetServer) Recv() (*ChangesetChunk, error) {
	m := new(ChangesetChunk)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// SliceService_ServiceDesc is the grpc.ServiceDesc for SliceService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SliceService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "slice.v1.SliceService",
	HandlerType: (*SliceServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CheckoutSlice",
			Handler:    _SliceService_CheckoutSlice_Handler,
		},
		{
			MethodName: "CreateChangeset",
			Handler:    _SliceService_CreateChangeset_Handler,
		},
		{
			MethodName: "ReviewChangeset",
			Handler:    _SliceService_ReviewChangeset_Handler,
		},
		{
			MethodName: "MergeChangeset",
			Handler:    _SliceService_MergeChangeset_Handler,
		},
		{
			MethodName: "RebaseChangeset",
			Handler:    _SliceService_RebaseChangeset_Handler,
		},
		{
			MethodName: "GetSliceCommits",
			Handler:    _SliceService_GetSliceCommits_Handler,
		},
		{
			MethodName: "GetSliceState",
			Handler:    _SliceService_GetSliceState_Handler,
		},
		{
			MethodName: "ListChangesets",
			Handler:    _SliceService_ListChangesets_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamCheckoutSlice",
			Handler:       _SliceService_StreamCheckoutSlice_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamCreateChangeset",
			Handler:       _SliceService_StreamCreateChangeset_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "slice_service.proto",
}
